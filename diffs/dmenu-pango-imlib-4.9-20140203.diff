--- config.def.h	2020-06-05 15:58:48.637068984 +0000
+++ config.def.h-patched	2020-06-05 20:22:55.703970771 +0000
@@ -1,23 +1,17 @@
 /* See LICENSE file for copyright and license details. */
-/* Default settings; can be overriden by command line. */
+/* vim: expandtab
+ */
+/* Default settings; can be overrided by command line. */
 
-static int topbar = 1;                      /* -b  option; if 0, dmenu appears at bottom     */
-/* -fn option overrides fonts[0]; default X11 font or font set */
-static const char *fonts[] = {
-	"monospace:size=10"
-};
-static const char *prompt      = NULL;      /* -p  option; prompt to the left of input field */
-static const char *colors[SchemeLast][2] = {
-	/*     fg         bg       */
-	[SchemeNorm] = { "#bbbbbb", "#222222" },
-	[SchemeSel] = { "#eeeeee", "#005577" },
-	[SchemeOut] = { "#000000", "#00ffff" },
-};
+static Bool topbar = True;                  /* -b  option; if False, dmenu appears at bottom */
+static const char *font = NULL;             /* -fn option; default X11 font or font set      */
+static const char *prompt = NULL;           /* -p  option; prompt to the elft of input field */
+static const char *normbgcolor = "#222222"; /* -nb option; normal background                 */
+static const char *normfgcolor = "#bbbbbb"; /* -nf option; normal foreground                 */
+static const char *selbgcolor  = "#005577"; /* -sb option; selected background               */
+static const char *selfgcolor  = "#eeeeee"; /* -sf option; selected foreground               */
+static const char *outbgcolor  = "#00ffff";
+static const char *outfgcolor  = "#000000";
 /* -l option; if nonzero, dmenu uses vertical list with given number of lines */
-static unsigned int lines      = 0;
+static unsigned int lines = 0;
 
-/*
- * Characters not considered part of a word while deleting words
- * for example: " /?\"&[]"
- */
-static const char worddelimiters[] = " ";
--- config.mk	2020-06-05 15:58:48.637068984 +0000
+++ config.mk-patched	2020-06-05 20:22:55.703970771 +0000
@@ -1,31 +1,33 @@
 # dmenu version
-VERSION = 4.9
+VERSION = 4.5-tip
 
 # paths
 PREFIX = /usr/local
-MANPREFIX = $(PREFIX)/share/man
+MANPREFIX = ${PREFIX}/share/man
 
 X11INC = /usr/X11R6/include
 X11LIB = /usr/X11R6/lib
 
+# Pango
+XFTINC = `pkg-config --cflags xft pango pangoxft`
+XFTLIBS  = -lXrender -lfreetype -lz `pkg-config --libs xft pango pangoxft`
+
+# Imlib
+IMLIBINC = `pkg-config --cflags imlib2 openssl`
+IMLIBLIBS = `pkg-config --libs imlib2 openssl`
+
 # Xinerama, comment if you don't want it
 XINERAMALIBS  = -lXinerama
 XINERAMAFLAGS = -DXINERAMA
 
-# freetype
-FREETYPELIBS = -lfontconfig -lXft
-FREETYPEINC = /usr/include/freetype2
-# OpenBSD (uncomment)
-#FREETYPEINC = $(X11INC)/freetype2
-
 # includes and libs
-INCS = -I$(X11INC) -I$(FREETYPEINC)
-LIBS = -L$(X11LIB) -lX11 $(XINERAMALIBS) $(FREETYPELIBS)
+INCS = -I${X11INC} ${XFTINC} ${IMLIBINC}
+LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${XFTLIBS} ${IMLIBLIBS}
 
 # flags
-CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700 -D_POSIX_C_SOURCE=200809L -DVERSION=\"$(VERSION)\" $(XINERAMAFLAGS)
-CFLAGS   = -std=c99 -pedantic -Wall -Os $(INCS) $(CPPFLAGS)
-LDFLAGS  = $(LIBS)
+CPPFLAGS = -DFORTIFY_SOURCE -D_BSD_SOURCE -D_POSIX_C_SOURCE=200809L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+CFLAGS   = -ansi -pedantic -Wall -Os ${INCS} ${CPPFLAGS}
+LDFLAGS  = -s ${LIBS}
 
 # compiler and linker
 CC = cc
--- dmenu.1	2020-06-05 15:58:48.637068984 +0000
+++ dmenu.1-patched	2020-06-05 20:22:55.703970771 +0000
@@ -3,11 +3,13 @@
 dmenu \- dynamic menu
 .SH SYNOPSIS
 .B dmenu
-.RB [ \-bfiv ]
+.RB [ \-b ]
+.RB [ \-f ]
+.RB [ \-i ]
 .RB [ \-l
-.IR lines ]
 .RB [ \-m
 .IR monitor ]
+.IR lines ]
 .RB [ \-p
 .IR prompt ]
 .RB [ \-fn
@@ -20,8 +22,7 @@
 .IR color ]
 .RB [ \-sf
 .IR color ]
-.RB [ \-w
-.IR windowid ]
+.RB [ \-v ]
 .P
 .BR dmenu_run " ..."
 .SH DESCRIPTION
@@ -30,6 +31,11 @@
 stdin.  When the user selects an item and presses Return, their choice is printed
 to stdout and dmenu terminates.  Entering text will narrow the items to those
 matching the tokens in the input.
+
+example pipe listing with images:
+   IMG:/mnt/pictures/lolcat.jpg\\tThis is a lolcat\\n
+   IMG:/mnt/pictures/david.jpg\\tThis is a picture of david\\n
+   This is a item without a picture\\n
 .P
 .B dmenu_run
 is a script used by
@@ -41,24 +47,29 @@
 dmenu appears at the bottom of the screen.
 .TP
 .B \-f
-dmenu grabs the keyboard before reading stdin if not reading from a tty. This
-is faster, but will lock up X until stdin reaches end\-of\-file.
+dmenu grabs the keyboard before reading stdin.  This is faster, but will lock up
+X until stdin reaches end\-of\-file.
 .TP
 .B \-i
 dmenu matches menu items case insensitively.
 .TP
+.B \-w
+wraps selection when reaching end of list or vice versa.
+.TP
+.B \-g
+dmenu generates thumbnails from piped data according to XDG thumbnail spec.
+.TP
 .BI \-l " lines"
 dmenu lists items vertically, with the given number of lines.
 .TP
 .BI \-m " monitor"
-dmenu is displayed on the monitor number supplied. Monitor numbers are starting
-from 0.
+dmenu is displayed on the monitor supplied.
 .TP
 .BI \-p " prompt"
 defines the prompt to be displayed to the left of the input field.
 .TP
 .BI \-fn " font"
-defines the font or font set used.
++defines the font or font set used. eg. "fixed" or "Monospace-12:normal" (an xft font)
 .TP
 .BI \-nb " color"
 defines the normal background color.
@@ -75,11 +86,20 @@
 .BI \-sf " color"
 defines the selected foreground color.
 .TP
+.BI \-si " selected index"
+hilight specified menu item by index automatically.
+.TP
+.BI \-is " image size"
+image size used for displaying images and generating cached versions.
+if previously used image was cached before with different -is parameter, it gets cached again.
+.TP
+.BI \-ia " image alignment"
+image alignment, valid options are: top-center, center, top, bottom
+every alignment has gapless version (ex. top-center-gapless)
+top-center is default
+.TP
 .B \-v
 prints version information to stdout, then exits.
-.TP
-.BI \-w " windowid"
-embed into windowid.
 .SH USAGE
 dmenu is completely controlled by the keyboard.  Items are selected using the
 arrow keys, page up, page down, home, and end.
@@ -100,94 +120,79 @@
 .B Escape
 Exit without selecting an item, returning failure.
 .TP
-.B Ctrl-Left
-Move cursor to the start of the current word
-.TP
-.B Ctrl-Right
-Move cursor to the end of the current word
-.TP
-.B C\-a
+C\-a
 Home
 .TP
-.B C\-b
+C\-b
 Left
 .TP
-.B C\-c
+C\-c
 Escape
 .TP
-.B C\-d
+C\-d
 Delete
 .TP
-.B C\-e
+C\-e
 End
 .TP
-.B C\-f
+C\-f
 Right
 .TP
-.B C\-g
+C\-g
 Escape
 .TP
-.B C\-h
+C\-h
 Backspace
 .TP
-.B C\-i
+C\-i
 Tab
 .TP
-.B C\-j
+C\-j
 Return
 .TP
-.B C\-J
+C\-J
 Shift-Return
 .TP
-.B C\-k
+C\-k
 Delete line right
 .TP
-.B C\-m
+C\-m
 Return
 .TP
-.B C\-M
-Shift-Return
-.TP
-.B C\-n
+C\-n
 Down
 .TP
-.B C\-p
+C\-p
 Up
 .TP
-.B C\-u
+C\-u
 Delete line left
 .TP
-.B C\-w
+C\-w
 Delete word left
 .TP
-.B C\-y
+C\-y
 Paste from primary X selection
 .TP
-.B C\-Y
+C\-Y
 Paste from X clipboard
 .TP
-.B M\-b
-Move cursor to the start of the current word
-.TP
-.B M\-f
-Move cursor to the end of the current word
-.TP
-.B M\-g
+M\-g
 Home
 .TP
-.B M\-G
+M\-G
 End
 .TP
-.B M\-h
+M\-h
 Up
 .TP
-.B M\-j
+M\-j
 Page down
 .TP
-.B M\-k
+M\-k
 Page up
 .TP
-.B M\-l
+M\-l
 Down
 .SH SEE ALSO
 .IR dwm (1),
--- dmenu.c	2020-06-05 15:58:48.637068984 +0000
+++ dmenu.c-patched	2020-06-05 20:22:55.703970771 +0000
@@ -1,67 +1,360 @@
 /* See LICENSE file for copyright and license details. */
 #include <ctype.h>
-#include <locale.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <strings.h>
+#include <errno.h>
+#include <pwd.h>
+#include <sys/stat.h>
 #include <time.h>
+#include <utime.h>
 #include <unistd.h>
-
 #include <X11/Xlib.h>
 #include <X11/Xatom.h>
 #include <X11/Xutil.h>
 #ifdef XINERAMA
 #include <X11/extensions/Xinerama.h>
 #endif
-#include <X11/Xft/Xft.h>
-
-#include "drw.h"
-#include "util.h"
+#include <Imlib2.h>
+#include <openssl/md5.h>
+#include "draw.h"
 
-/* macros */
 #define INTERSECT(x,y,w,h,r)  (MAX(0, MIN((x)+(w),(r).x_org+(r).width)  - MAX((x),(r).x_org)) \
                              * MAX(0, MIN((y)+(h),(r).y_org+(r).height) - MAX((y),(r).y_org)))
-#define LENGTH(X)             (sizeof X / sizeof X[0])
-#define TEXTW(X)              (drw_fontset_getwidth(drw, (X)) + lrpad)
-
-/* enums */
-enum { SchemeNorm, SchemeSel, SchemeOut, SchemeLast }; /* color schemes */
+#ifndef MIN
+#define MIN(a,b)              ((a) < (b) ? (a) : (b))
+#endif
+#ifndef MAX
+#define MAX(a,b)              ((a) > (b) ? (a) : (b))
+#endif
+#define DEFFONT "Monospace 12"
 
-struct item {
+typedef struct Item Item;
+struct Item {
 	char *text;
-	struct item *left, *right;
-	int out;
+	char *image;
+	Item *left, *right;
+	Bool out;
 };
 
+static void appenditem(Item *item, Item **list, Item **last);
+static void calcoffsets(void);
+static char *cistrstr(const char *s, const char *sub);
+static void drawmenu(void);
+static void grabkeyboard(void);
+static void insert(const char *str, ssize_t n);
+static void keypress(XKeyEvent *ev);
+static void match(void);
+static size_t nextrune(int inc);
+static void paste(void);
+static void readstdin(void);
+static void drawimage(void);
+static void run(void);
+static void cleanup(void);
+static void jumptoindex(unsigned int index);
+static void resizetoimageheight(int imageheight);
+static void setup(void);
+static void usage(void);
+
+typedef enum image_mode {
+	MODE_TOP_CENTER,
+	MODE_CENTER,
+	MODE_TOP,
+	MODE_BOTTOM
+} image_mode;
+
 static char text[BUFSIZ] = "";
-static char *embed;
 static int bh, mw, mh;
-static int inputw = 0, promptw;
-static int lrpad; /* sum of left and right padding */
-static size_t cursor;
-static struct item *items = NULL;
-static struct item *matches, *matchend;
-static struct item *prev, *curr, *next, *sel;
-static int mon = -1, screen;
-
+static int inputw, promptw;
+static size_t cursor = 0;
+static unsigned int selected = 0;
+static ColorSet *normcol;
+static ColorSet *selcol;
+static ColorSet *outcol;
 static Atom clip, utf8;
-static Display *dpy;
-static Window root, parentwin, win;
+static DC *dc;
+static Item *items = NULL;
+static Item *matches, *matchend;
+static Item *prev, *curr, *next, *sel;
+static Window win;
 static XIC xic;
-
-static Drw *drw;
-static Clr *scheme[SchemeLast];
+static int mon = -1;
+static int wrapselection = 0;
+static int reallines = 0;
+static int imagegaps = 4;
+static int imagewidth = 86;
+static int imageheight = 86;
+static int longestedge = 0;
+static int generatecache = 0;
+static image_mode imagemode = MODE_TOP_CENTER;
+static Imlib_Image image = NULL;
 
 #include "config.h"
 
 static int (*fstrncmp)(const char *, const char *, size_t) = strncmp;
 static char *(*fstrstr)(const char *, const char *) = strstr;
 
-static void
-appenditem(struct item *item, struct item **list, struct item **last)
+static void createifnexist(const char *dir) {
+	if(access(dir, F_OK) == 0) return;
+	if(errno == EACCES) eprintf("no access to create directory: %s\n", dir);
+	if(mkdir(dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) == -1)
+		eprintf("failed to create directory: %s\n", dir);
+}
+
+static void createifnexist_rec(const char *dir) {
+	char *buf, *s = (char*)dir, *bs;
+    if(!(buf = malloc(strlen(s)+1)))
+		return;
+	memset(buf, 0, strlen(s)+1);
+	for(bs = buf; *s; ++s, ++bs) {
+		if(*s == '/' && *buf) createifnexist(buf);
+		*bs = *s;
+	}
+	free(buf);
+}
+
+static void loadimage(const char *file, int *width, int *height) {
+	image = imlib_load_image(file);
+	if (!image) return;
+	imlib_context_set_image(image);
+	*width = imlib_image_get_width();
+	*height = imlib_image_get_height();
+}
+
+static void scaleimage(int *width, int *height)
 {
-	if (*last)
+	int nwidth, nheight;
+	float aspect = 1.0f;
+
+	if (imagewidth > *width)
+		aspect = (float)(*width)/imagewidth;
+	else
+		aspect = (float)imagewidth/(*width);
+
+	nwidth = *width * aspect;
+	nheight = *height * aspect;
+	if(nwidth == *width && nheight == *height) return;
+	image = imlib_create_cropped_scaled_image(0,0,*width,*height,nwidth,nheight);
+	imlib_free_image();
+	if(!image) return;
+	imlib_context_set_image(image);
+	*width = nwidth;
+	*height = nheight;
+}
+
+static time_t
+mtime(const char *file) {
+	struct stat statbuf;
+	if(stat(file, &statbuf) == -1) return 0;
+	return statbuf.st_mtime;
+}
+
+static void
+loadimagecache(const char *file, int *width, int *height) {
+	int slen = 0, i, cache = 1;
+	unsigned char digest[MD5_DIGEST_LENGTH];
+	char md5[MD5_DIGEST_LENGTH*2+1];
+	char *xdg_cache, *home = NULL, *dsize, *buf;
+	struct passwd *pw = NULL;
+
+	/* just load and don't store or try cache */
+	if(longestedge > 256) {
+		loadimage(file, width, height);
+		if (image) scaleimage(width, height);
+		return;
+	}
+
+	/* try find image from cache first */
+	if(!(xdg_cache = getenv("XDG_CACHE_HOME"))) {
+		if(!(home = getenv("HOME")) && (pw = getpwuid(getuid())))
+			home = pw->pw_dir;
+		if(!home) {
+			eprintf("could not find home directory");
+			return;
+		}
+	}
+
+	/* which cache do we try? */
+	dsize = "normal";
+	if (longestedge > 128) dsize = "large";
+
+	slen = snprintf(NULL, 0, "file://%s", file)+1;
+	if(!(buf = malloc(slen))) {
+		eprintf("out of memory");
+		return;
+	}
+
+	/* calculate md5 from path */
+	sprintf(buf, "file://%s", file);
+	MD5((unsigned char*)buf, slen, digest);
+	free(buf);
+	for(i = 0; i < MD5_DIGEST_LENGTH; ++i) sprintf(&md5[i*2], "%02x", (unsigned int)digest[i]);
+
+	/* path for cached thumbnail */
+	if(xdg_cache) slen = snprintf(NULL, 0, "%s/thumbnails/%s/%s.png", xdg_cache, dsize, md5)+1;
+	else slen = snprintf(NULL, 0, "%s/.thumbnails/%s/%s.png", home, dsize, md5)+1;
+
+	if(!(buf = malloc(slen))) {
+		eprintf("out of memory");
+		return;
+	}
+
+	if(xdg_cache) sprintf(buf, "%s/thumbnails/%s/%s.png", xdg_cache, dsize, md5);
+	else sprintf(buf, "%s/.thumbnails/%s/%s.png", home, dsize, md5);
+
+	loadimage(buf, width, height);
+	if(image && mtime(buf) != mtime(file)) {
+		imlib_free_image();
+		image = NULL;
+		remove(buf); /* this needs to be recreated anyway */
+	} else if(image && *width < imagewidth && *height < imageheight) {
+		imlib_free_image();
+		image = NULL;
+	} else if(image && (*width > imagewidth || *height > imageheight)) {
+		scaleimage(width, height);
+	}
+
+	/* we are done */
+    if(image) {
+		free(buf);
+		return;
+	}
+
+    /* we din't find anything from cache, or it was just wrong */
+	loadimage(file, width, height);
+	if(!image) {
+		free(buf);
+		return;
+	}
+
+	if (*width < imagewidth && *height < imageheight) {
+		cache = 0;
+	}
+	scaleimage(width, height);
+	if (cache) {
+		struct utimbuf newtime;
+		struct stat orig;
+		stat(file, &orig);
+		imlib_image_set_format("png");
+		createifnexist_rec(buf);
+		imlib_save_image(buf);
+		newtime.actime = orig.st_atime;
+		newtime.modtime = orig.st_mtime;
+		utime(buf, &newtime);
+
+	}
+	free(buf);
+}
+
+int
+main(int argc, char *argv[]) {
+	Bool fast = False;
+	int i;
+
+	for(i = 1; i < argc; i++)
+		/* these options take no arguments */
+		if(!strcmp(argv[i], "-v")) {      /* prints version information */
+			puts("dmenu-pango-imlib "VERSION", © 2006-2013 dmenu engineers, see LICENSE for details");
+			exit(EXIT_SUCCESS);
+		}
+		else if(!strcmp(argv[i], "-b"))   /* appears at the bottom of the screen */
+			topbar = False;
+		else if(!strcmp(argv[i], "-f"))   /* grabs keyboard before reading stdin */
+			fast = True;
+		else if(!strcmp(argv[i], "-i")) { /* case-insensitive item matching */
+			fstrncmp = strncasecmp;
+			fstrstr = cistrstr;
+		}
+		else if(!strcmp(argv[i], "-w")) /* wrap selection */
+			wrapselection = 1;
+		else if(!strcmp(argv[i], "-g")) /* generate image cache */
+			generatecache = 1;
+		else if(i+1 == argc)
+			usage();
+		/* these options take one argument */
+		else if(!strcmp(argv[i], "-l"))   /* number of lines in vertical list */
+			lines = atoi(argv[++i]);
+		else if(!strcmp(argv[i], "-m"))
+			mon = atoi(argv[++i]);
+		else if(!strcmp(argv[i], "-p"))   /* adds prompt to left of input field */
+			prompt = argv[++i];
+		else if(!strcmp(argv[i], "-fn"))  /* font or font set */
+			font = argv[++i];
+		else if(!strcmp(argv[i], "-nb"))  /* normal background color */
+			normbgcolor = argv[++i];
+		else if(!strcmp(argv[i], "-nf"))  /* normal foreground color */
+			normfgcolor = argv[++i];
+		else if(!strcmp(argv[i], "-sb"))  /* selected background color */
+			selbgcolor = argv[++i];
+		else if(!strcmp(argv[i], "-sf"))  /* selected foreground color */
+			selfgcolor = argv[++i];
+		else if(!strcmp(argv[i], "-si"))  /* selected index */
+			selected = atoi(argv[++i]);
+		else if(!strcmp(argv[i], "-is")) {  /* image size */
+			char buf[255];
+			memset(buf, 0, sizeof(buf));
+			memcpy(buf, argv[++i], sizeof(buf)-1);
+			if(sscanf(buf, "%dx%d", &imagewidth, &imageheight) == 1)
+				imageheight = imagewidth;
+		} else if(!strcmp(argv[i], "-ia")) {/* image alignment */
+			char *arg = argv[++i];
+			if (!strcmp(arg, "center")) imagemode = MODE_CENTER;
+			if (!strcmp(arg, "top")) imagemode = MODE_TOP;
+			if (!strcmp(arg, "bottom")) imagemode = MODE_BOTTOM;
+			if (!strcmp(arg, "top-center-gapless")) imagegaps = 0;
+			if (!strcmp(arg, "center-gapless")) {
+				imagegaps = 0;
+				imagemode = MODE_CENTER;
+			}
+			if (!strcmp(arg, "top-gapless")) {
+				imagegaps = 0;
+				imagemode = MODE_TOP;
+			}
+			if (!strcmp(arg, "bottom-gapless")) {
+				imagegaps = 0;
+				imagemode = MODE_BOTTOM;
+			}
+		}
+		else
+			usage();
+
+	longestedge = MAX(imagewidth, imageheight);
+
+	dc = initdc();
+	initfont(dc, (font?font:DEFFONT));
+	atexit(cleanup);
+
+	if(fast) {
+		grabkeyboard();
+		readstdin();
+	}
+	else {
+		readstdin();
+		grabkeyboard();
+	}
+	setup();
+	run();
+
+	return 1; /* unreachable */
+}
+
+void
+cleanup(void) {
+	if(image) {
+		imlib_free_image();
+		image = NULL;
+	}
+	freecol(dc, normcol);
+	freecol(dc, selcol);
+	XDestroyWindow(dc->dpy, win);
+	XUngrabKeyboard(dc->dpy, CurrentTime);
+	freedc(dc);
+}
+
+void
+appenditem(Item *item, Item **list, Item **last) {
+	if(*last)
 		(*last)->right = item;
 	else
 		*list = item;
@@ -71,259 +364,127 @@
 	*last = item;
 }
 
-static void
-calcoffsets(void)
-{
+void
+calcoffsets(void) {
 	int i, n;
 
-	if (lines > 0)
+	if(lines > 0)
 		n = lines * bh;
 	else
-		n = mw - (promptw + inputw + TEXTW("<") + TEXTW(">"));
+		n = mw - (promptw + inputw + textw(dc, "<") + textw(dc, ">"));
 	/* calculate which items will begin the next page and previous page */
-	for (i = 0, next = curr; next; next = next->right)
-		if ((i += (lines > 0) ? bh : MIN(TEXTW(next->text), n)) > n)
+	for(i = 0, next = curr; next; next = next->right)
+		if((i += (lines > 0) ? bh : MIN(textw(dc, next->text), n)) > n)
 			break;
-	for (i = 0, prev = curr; prev && prev->left; prev = prev->left)
-		if ((i += (lines > 0) ? bh : MIN(TEXTW(prev->left->text), n)) > n)
+	for(i = 0, prev = curr; prev && prev->left; prev = prev->left)
+		if((i += (lines > 0) ? bh : MIN(textw(dc, prev->left->text), n)) > n)
 			break;
 }
 
-static void
-cleanup(void)
-{
-	size_t i;
-
-	XUngrabKey(dpy, AnyKey, AnyModifier, root);
-	for (i = 0; i < SchemeLast; i++)
-		free(scheme[i]);
-	drw_free(drw);
-	XSync(dpy, False);
-	XCloseDisplay(dpy);
-}
-
-static char *
-cistrstr(const char *s, const char *sub)
-{
-	size_t len;
-
-	for (len = strlen(sub); *s; s++)
-		if (!strncasecmp(s, sub, len))
-			return (char *)s;
+char *
+cistrstr(const char *hay, const char *needle) {
+	size_t i, r, p, len, len2;
+	p = 0; r = 0;
+	if (!strcasecmp(hay, needle)) return (char*)hay;
+	if ((len = strlen(hay)) < (len2 = strlen(needle))) return NULL;
+	for (i = 0; i != len; ++i) {
+		if (p == len2) return (char*)&hay[r]; /* THIS IS IT! */
+		if (toupper(hay[i]) == toupper(needle[p++])) {
+			if (!r) r = i; /* could this be.. */
+		} else { if (r) i = r; r = 0; p = 0; } /* ..nope, damn it! */
+	}
+	if (p == len2) return (char*)&hay[r]; /* THIS IS IT! */
 	return NULL;
 }
 
-static int
-drawitem(struct item *item, int x, int y, int w)
-{
-	if (item == sel)
-		drw_setscheme(drw, scheme[SchemeSel]);
-	else if (item->out)
-		drw_setscheme(drw, scheme[SchemeOut]);
-	else
-		drw_setscheme(drw, scheme[SchemeNorm]);
-
-	return drw_text(drw, x, y, w, bh, lrpad / 2, item->text, 0);
-}
-
-static void
-drawmenu(void)
-{
-	unsigned int curpos;
-	struct item *item;
-	int x = 0, y = 0, w;
-
-	drw_setscheme(drw, scheme[SchemeNorm]);
-	drw_rect(drw, 0, 0, mw, mh, 1, 1);
-
-	if (prompt && *prompt) {
-		drw_setscheme(drw, scheme[SchemeSel]);
-		x = drw_text(drw, x, 0, promptw, bh, lrpad / 2, prompt, 0);
+void
+drawmenu(void) {
+	int curpos;
+	Item *item;
+
+	dc->x = 0;
+	dc->y = 0;
+	dc->h = bh;
+	drawrect(dc, 0, 0, mw, mh, True, normcol->BG);
+
+	if(prompt && *prompt) {
+		dc->w = promptw;
+		drawtext(dc, prompt, selcol);
+		dc->x = dc->w;
 	}
 	/* draw input field */
-	w = (lines > 0 || !matches) ? mw - x : inputw;
-	drw_setscheme(drw, scheme[SchemeNorm]);
-	drw_text(drw, x, 0, w, bh, lrpad / 2, text, 0);
+	dc->w = (lines > 0 || !matches) ? mw - dc->x : inputw;
+	drawtext(dc, text, normcol);
+	if((curpos = textnw(dc, text, cursor) + dc->h/2 - 2) < dc->w)
+		drawrect(dc, curpos, 2, 1, dc->h - 4, True, normcol->FG);
 
-	curpos = TEXTW(text) - TEXTW(&text[cursor]);
-	if ((curpos += lrpad / 2 - 1) < w) {
-		drw_setscheme(drw, scheme[SchemeNorm]);
-		drw_rect(drw, x + curpos, 2, 2, bh - 4, 1, 0);
-	}
-
-	if (lines > 0) {
+	if(lines > 0) {
 		/* draw vertical list */
-		for (item = curr; item != next; item = item->right)
-			drawitem(item, x, y += bh, mw - x);
-	} else if (matches) {
-		/* draw horizontal list */
-		x += inputw;
-		w = TEXTW("<");
-		if (curr->left) {
-			drw_setscheme(drw, scheme[SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, lrpad / 2, "<", 0);
-		}
-		x += w;
-		for (item = curr; item != next; item = item->right)
-			x = drawitem(item, x, 0, MIN(TEXTW(item->text), mw - x - TEXTW(">")));
-		if (next) {
-			w = TEXTW(">");
-			drw_setscheme(drw, scheme[SchemeNorm]);
-			drw_text(drw, mw - w, 0, w, bh, lrpad / 2, ">", 0);
+		if(longestedge && imagewidth) dc->x = imagewidth+imagegaps;
+		dc->w = mw - dc->x;
+		for(item = curr; item != next; item = item->right) {
+			dc->y += dc->h;
+			drawtext(dc, item->text, (item == sel) ? selcol :
+			                         (item->out)   ? outcol : normcol);
 		}
 	}
-	drw_map(drw, win, 0, 0, mw, mh);
-}
-
-static void
-grabfocus(void)
-{
-	struct timespec ts = { .tv_sec = 0, .tv_nsec = 10000000  };
-	Window focuswin;
-	int i, revertwin;
-
-	for (i = 0; i < 100; ++i) {
-		XGetInputFocus(dpy, &focuswin, &revertwin);
-		if (focuswin == win)
-			return;
-		XSetInputFocus(dpy, win, RevertToParent, CurrentTime);
-		nanosleep(&ts, NULL);
+	else if(matches) {
+		/* draw horizontal list */
+		dc->x += inputw;
+		dc->w = textw(dc, "<");
+		if(curr->left)
+			drawtext(dc, "<", normcol);
+		for(item = curr; item != next; item = item->right) {
+			dc->x += dc->w;
+			dc->w = MIN(textw(dc, item->text), mw - dc->x - textw(dc, ">"));
+			drawtext(dc, item->text, (item == sel) ? selcol :
+			                         (item->out)   ? outcol : normcol);
+		}
+		dc->w = textw(dc, ">");
+		dc->x = mw - dc->w;
+		if(next)
+			drawtext(dc, ">", normcol);
 	}
-	die("cannot grab focus");
+	mapdc(dc, win, mw, mh);
 }
 
-static void
-grabkeyboard(void)
-{
-	struct timespec ts = { .tv_sec = 0, .tv_nsec = 1000000  };
+void
+grabkeyboard(void) {
 	int i;
 
-	if (embed)
-		return;
 	/* try to grab keyboard, we may have to wait for another process to ungrab */
-	for (i = 0; i < 1000; i++) {
-		if (XGrabKeyboard(dpy, DefaultRootWindow(dpy), True, GrabModeAsync,
-		                  GrabModeAsync, CurrentTime) == GrabSuccess)
+	for(i = 0; i < 1000; i++) {
+		if(XGrabKeyboard(dc->dpy, DefaultRootWindow(dc->dpy), True,
+		                 GrabModeAsync, GrabModeAsync, CurrentTime) == GrabSuccess)
 			return;
-		nanosleep(&ts, NULL);
-	}
-	die("cannot grab keyboard");
-}
-
-static void
-match(void)
-{
-	static char **tokv = NULL;
-	static int tokn = 0;
-
-	char buf[sizeof text], *s;
-	int i, tokc = 0;
-	size_t len, textsize;
-	struct item *item, *lprefix, *lsubstr, *prefixend, *substrend;
-
-	strcpy(buf, text);
-	/* separate input text into tokens to be matched individually */
-	for (s = strtok(buf, " "); s; tokv[tokc - 1] = s, s = strtok(NULL, " "))
-		if (++tokc > tokn && !(tokv = realloc(tokv, ++tokn * sizeof *tokv)))
-			die("cannot realloc %u bytes:", tokn * sizeof *tokv);
-	len = tokc ? strlen(tokv[0]) : 0;
-
-	matches = lprefix = lsubstr = matchend = prefixend = substrend = NULL;
-	textsize = strlen(text) + 1;
-	for (item = items; item && item->text; item++) {
-		for (i = 0; i < tokc; i++)
-			if (!fstrstr(item->text, tokv[i]))
-				break;
-		if (i != tokc) /* not all tokens match */
-			continue;
-		/* exact matches go first, then prefixes, then substrings */
-		if (!tokc || !fstrncmp(text, item->text, textsize))
-			appenditem(item, &matches, &matchend);
-		else if (!fstrncmp(tokv[0], item->text, len))
-			appenditem(item, &lprefix, &prefixend);
-		else
-			appenditem(item, &lsubstr, &substrend);
-	}
-	if (lprefix) {
-		if (matches) {
-			matchend->right = lprefix;
-			lprefix->left = matchend;
-		} else
-			matches = lprefix;
-		matchend = prefixend;
-	}
-	if (lsubstr) {
-		if (matches) {
-			matchend->right = lsubstr;
-			lsubstr->left = matchend;
-		} else
-			matches = lsubstr;
-		matchend = substrend;
+		usleep(1000);
 	}
-	curr = sel = matches;
-	calcoffsets();
+	eprintf("cannot grab keyboard\n");
 }
 
-static void
-insert(const char *str, ssize_t n)
-{
-	if (strlen(text) + n > sizeof text - 1)
+void
+insert(const char *str, ssize_t n) {
+	if(strlen(text) + n > sizeof text - 1)
 		return;
 	/* move existing text out of the way, insert new text, and update cursor */
 	memmove(&text[cursor + n], &text[cursor], sizeof text - cursor - MAX(n, 0));
-	if (n > 0)
+	if(n > 0)
 		memcpy(&text[cursor], str, n);
 	cursor += n;
 	match();
 }
 
-static size_t
-nextrune(int inc)
-{
-	ssize_t n;
-
-	/* return location of next utf8 rune in the given direction (+1 or -1) */
-	for (n = cursor + inc; n + inc >= 0 && (text[n] & 0xc0) == 0x80; n += inc)
-		;
-	return n;
-}
-
-static void
-movewordedge(int dir)
-{
-	if (dir < 0) { /* move cursor to the start of the word*/
-		while (cursor > 0 && strchr(worddelimiters, text[nextrune(-1)]))
-			cursor = nextrune(-1);
-		while (cursor > 0 && !strchr(worddelimiters, text[nextrune(-1)]))
-			cursor = nextrune(-1);
-	} else { /* move cursor to the end of the word */
-		while (text[cursor] && strchr(worddelimiters, text[cursor]))
-			cursor = nextrune(+1);
-		while (text[cursor] && !strchr(worddelimiters, text[cursor]))
-			cursor = nextrune(+1);
-	}
-}
-
-static void
-keypress(XKeyEvent *ev)
-{
+void
+keypress(XKeyEvent *ev) {
 	char buf[32];
 	int len;
-	KeySym ksym;
+	KeySym ksym = NoSymbol;
 	Status status;
 
 	len = XmbLookupString(xic, ev, buf, sizeof buf, &ksym, &status);
-	switch (status) {
-	default: /* XLookupNone, XBufferOverflow */
+	if(status == XBufferOverflow)
 		return;
-	case XLookupChars:
-		goto insert;
-	case XLookupKeySym:
-	case XLookupBoth:
-		break;
-	}
-
-	if (ev->state & ControlMask) {
+	if(ev->state & ControlMask)
 		switch(ksym) {
 		case XK_a: ksym = XK_Home;      break;
 		case XK_b: ksym = XK_Left;      break;
@@ -335,9 +496,9 @@
 		case XK_h: ksym = XK_BackSpace; break;
 		case XK_i: ksym = XK_Tab;       break;
 		case XK_j: /* fallthrough */
-		case XK_J: /* fallthrough */
+		case XK_J: ksym = XK_Return;    break;
 		case XK_m: /* fallthrough */
-		case XK_M: ksym = XK_Return; ev->state &= ~ControlMask; break;
+		case XK_M: ksym = XK_Return;    break;
 		case XK_n: ksym = XK_Down;      break;
 		case XK_p: ksym = XK_Up;        break;
 
@@ -349,39 +510,25 @@
 			insert(NULL, 0 - cursor);
 			break;
 		case XK_w: /* delete word */
-			while (cursor > 0 && strchr(worddelimiters, text[nextrune(-1)]))
+			while(cursor > 0 && text[nextrune(-1)] == ' ')
 				insert(NULL, nextrune(-1) - cursor);
-			while (cursor > 0 && !strchr(worddelimiters, text[nextrune(-1)]))
+			while(cursor > 0 && text[nextrune(-1)] != ' ')
 				insert(NULL, nextrune(-1) - cursor);
 			break;
 		case XK_y: /* paste selection */
-		case XK_Y:
-			XConvertSelection(dpy, (ev->state & ShiftMask) ? clip : XA_PRIMARY,
+			XConvertSelection(dc->dpy, (ev->state & ShiftMask) ? clip : XA_PRIMARY,
 			                  utf8, utf8, win, CurrentTime);
 			return;
-		case XK_Left:
-			movewordedge(-1);
-			goto draw;
-		case XK_Right:
-			movewordedge(+1);
-			goto draw;
 		case XK_Return:
 		case XK_KP_Enter:
 			break;
 		case XK_bracketleft:
-			cleanup();
-			exit(1);
+			exit(EXIT_FAILURE);
 		default:
 			return;
 		}
-	} else if (ev->state & Mod1Mask) {
+	else if(ev->state & Mod1Mask)
 		switch(ksym) {
-		case XK_b:
-			movewordedge(-1);
-			goto draw;
-		case XK_f:
-			movewordedge(+1);
-			goto draw;
 		case XK_g: ksym = XK_Home;  break;
 		case XK_G: ksym = XK_End;   break;
 		case XK_h: ksym = XK_Up;    break;
@@ -391,45 +538,41 @@
 		default:
 			return;
 		}
-	}
-
 	switch(ksym) {
 	default:
-insert:
-		if (!iscntrl(*buf))
+		if(!iscntrl(*buf))
 			insert(buf, len);
 		break;
 	case XK_Delete:
-		if (text[cursor] == '\0')
+		if(text[cursor] == '\0')
 			return;
 		cursor = nextrune(+1);
 		/* fallthrough */
 	case XK_BackSpace:
-		if (cursor == 0)
+		if(cursor == 0)
 			return;
 		insert(NULL, nextrune(-1) - cursor);
 		break;
 	case XK_End:
-		if (text[cursor] != '\0') {
+		if(text[cursor] != '\0') {
 			cursor = strlen(text);
 			break;
 		}
-		if (next) {
+		if(next) {
 			/* jump to end of list and position items in reverse */
 			curr = matchend;
 			calcoffsets();
 			curr = prev;
 			calcoffsets();
-			while (next && (curr = curr->right))
+			while(next && (curr = curr->right))
 				calcoffsets();
 		}
 		sel = matchend;
 		break;
 	case XK_Escape:
-		cleanup();
-		exit(1);
+		exit(EXIT_FAILURE);
 	case XK_Home:
-		if (sel == matches) {
+		if(sel == matches) {
 			cursor = 0;
 			break;
 		}
@@ -437,27 +580,37 @@
 		calcoffsets();
 		break;
 	case XK_Left:
-		if (cursor > 0 && (!sel || !sel->left || lines > 0)) {
+		if(cursor > 0 && (!sel || !sel->left || lines > 0)) {
 			cursor = nextrune(-1);
 			break;
 		}
-		if (lines > 0)
+		if(lines > 0)
 			return;
 		/* fallthrough */
 	case XK_Up:
-		if (sel && sel->left && (sel = sel->left)->right == curr) {
+		if(sel && sel->left) {
+			if ((sel = sel->left)->right == curr) {
+				curr = prev;
+				calcoffsets();
+			}
+		} else if(wrapselection) {
+			curr = matchend;
+			calcoffsets();
 			curr = prev;
 			calcoffsets();
+			while(next && (curr = curr->right))
+				calcoffsets();
+			sel = matchend;
 		}
 		break;
 	case XK_Next:
-		if (!next)
+		if(!next)
 			return;
 		sel = curr = next;
 		calcoffsets();
 		break;
 	case XK_Prior:
-		if (!prev)
+		if(!prev)
 			return;
 		sel = curr = prev;
 		calcoffsets();
@@ -465,29 +618,31 @@
 	case XK_Return:
 	case XK_KP_Enter:
 		puts((sel && !(ev->state & ShiftMask)) ? sel->text : text);
-		if (!(ev->state & ControlMask)) {
-			cleanup();
-			exit(0);
-		}
-		if (sel)
-			sel->out = 1;
+		if(!(ev->state & ControlMask))
+			exit(EXIT_SUCCESS);
+		sel->out = True;
 		break;
 	case XK_Right:
-		if (text[cursor] != '\0') {
+		if(text[cursor] != '\0') {
 			cursor = nextrune(+1);
 			break;
 		}
-		if (lines > 0)
+		if(lines > 0)
 			return;
 		/* fallthrough */
 	case XK_Down:
-		if (sel && sel->right && (sel = sel->right) == next) {
-			curr = next;
+		if(sel && sel->right) {
+			if ((sel = sel->right) == next) {
+				curr = next;
+				calcoffsets();
+			}
+		} else if(wrapselection) {
+			sel = curr = matches;
 			calcoffsets();
 		}
 		break;
 	case XK_Tab:
-		if (!sel)
+		if(!sel)
 			return;
 		strncpy(text, sel->text, sizeof text - 1);
 		text[sizeof text - 1] = '\0';
@@ -495,277 +650,343 @@
 		match();
 		break;
 	}
-
-draw:
 	drawmenu();
 }
 
-static void
-paste(void)
-{
+void
+match(void) {
+	static char **tokv = NULL;
+	static int tokn = 0;
+	static size_t oldlen = 0;
+
+	char buf[sizeof text], *s;
+	int i, tokc = 0;
+	size_t len;
+	Item *item, *lprefix, *lsubstr, *prefixend, *substrend;
+
+	/* small optimization */
+	len = strlen(text);
+	if (!matches && oldlen && len >= oldlen)
+		return;
+	oldlen = len;
+
+	strcpy(buf, text);
+	/* separate input text into tokens to be matched individually */
+	for(s = strtok(buf, " "); s; tokv[tokc-1] = s, s = strtok(NULL, " "))
+		if(++tokc > tokn && !(tokv = realloc(tokv, ++tokn * sizeof *tokv)))
+			eprintf("cannot realloc %u bytes\n", tokn * sizeof *tokv);
+	len = tokc ? strlen(tokv[0]) : 0;
+
+	matches = lprefix = lsubstr = matchend = prefixend = substrend = NULL;
+	for(item = items; item && item->text; item++) {
+		for(i = 0; i < tokc; i++)
+			if(!fstrstr(item->text, tokv[i]))
+				break;
+		if(i != tokc) /* not all tokens match */
+			continue;
+		/* exact matches go first, then prefixes, then substrings */
+		if(!tokc || !fstrncmp(tokv[0], item->text, len+1))
+			appenditem(item, &matches, &matchend);
+		else if(!fstrncmp(tokv[0], item->text, len))
+			appenditem(item, &lprefix, &prefixend);
+		else
+			appenditem(item, &lsubstr, &substrend);
+	}
+	if(lprefix) {
+		if(matches) {
+			matchend->right = lprefix;
+			lprefix->left = matchend;
+		}
+		else
+			matches = lprefix;
+		matchend = prefixend;
+	}
+	if(lsubstr) {
+		if(matches) {
+			matchend->right = lsubstr;
+			lsubstr->left = matchend;
+		}
+		else
+			matches = lsubstr;
+		matchend = substrend;
+	}
+	curr = sel = matches;
+	calcoffsets();
+}
+
+size_t
+nextrune(int inc) {
+	ssize_t n;
+
+	/* return location of next utf8 rune in the given direction (+1 or -1) */
+	for(n = cursor + inc; n + inc >= 0 && (text[n] & 0xc0) == 0x80; n += inc);
+	return n;
+}
+
+void
+paste(void) {
 	char *p, *q;
 	int di;
 	unsigned long dl;
 	Atom da;
 
 	/* we have been given the current selection, now insert it into input */
-	if (XGetWindowProperty(dpy, win, utf8, 0, (sizeof text / 4) + 1, False,
-	                   utf8, &da, &di, &dl, &dl, (unsigned char **)&p)
-	    == Success && p) {
-		insert(p, (q = strchr(p, '\n')) ? q - p : (ssize_t)strlen(p));
-		XFree(p);
-	}
+	XGetWindowProperty(dc->dpy, win, utf8, 0, (sizeof text / 4) + 1, False,
+	                   utf8, &da, &di, &dl, &dl, (unsigned char **)&p);
+	insert(p, (q = strchr(p, '\n')) ? q-p : (ssize_t)strlen(p));
+	XFree(p);
 	drawmenu();
 }
 
-static void
-readstdin(void)
-{
-	char buf[sizeof text], *p;
-	size_t i, imax = 0, size = 0;
-	unsigned int tmpmax = 0;
+void
+readstdin(void) {
+	char buf[sizeof text], *p, *maxstr = NULL;
+	size_t i, max = 0, size = 0;
+	int w, h;
+	char *limg = NULL;
 
 	/* read each line from stdin and add it to the item list */
-	for (i = 0; fgets(buf, sizeof buf, stdin); i++) {
-		if (i + 1 >= size / sizeof *items)
-			if (!(items = realloc(items, (size += BUFSIZ))))
-				die("cannot realloc %u bytes:", size);
-		if ((p = strchr(buf, '\n')))
+	for(i = 0; fgets(buf, sizeof buf, stdin); i++) {
+		if(i+1 >= size / sizeof *items)
+			if(!(items = realloc(items, (size += BUFSIZ))))
+				eprintf("cannot realloc %u bytes:", size);
+		if((p = strchr(buf, '\n')))
 			*p = '\0';
-		if (!(items[i].text = strdup(buf)))
-			die("cannot strdup %u bytes:", strlen(buf) + 1);
-		items[i].out = 0;
-		drw_font_getexts(drw->fonts, buf, strlen(buf), &tmpmax, NULL);
-		if (tmpmax > inputw) {
-			inputw = tmpmax;
-			imax = i;
+		if(!(items[i].text = strdup(buf)))
+			eprintf("cannot strdup %u bytes:", strlen(buf)+1);
+		items[i].out = False;
+		if(strlen(items[i].text) > max)
+			max = strlen(maxstr = items[i].text);
+
+		/* read image */
+		if(!strncmp("IMG:", items[i].text, strlen("IMG:"))) {
+			if(!(items[i].image = malloc(strlen(items[i].text)+1)))
+				eprintf("cannot malloc %u bytes\n", strlen(items[i].text));
+			if(sscanf(items[i].text, "IMG:%[^\t]", items[i].image)) {
+				if(!(items[i].image = realloc(items[i].image, strlen(items[i].image)+1)))
+					eprintf("cannot realloc %u bytes\n", strlen(items[i].image)+1);
+				items[i].text += strlen("IMG:")+strlen(items[i].image)+1;
+			} else {
+				free(items[i].image);
+				items[i].image = NULL;
+			}
+		} else items[i].image = NULL;
+
+		/* cache image immediatly */
+		if(generatecache && longestedge <= 256 && items[i].image && strcmp(items[i].image, limg?limg:"")) {
+			loadimagecache(items[i].image, &w, &h);
+			fprintf(stderr, "-!- Generating thumbnail for: %s\n", items[i].image);
 		}
+		if(items[i].image) limg = items[i].image;
 	}
-	if (items)
+	if(items) {
 		items[i].text = NULL;
-	inputw = items ? TEXTW(items[imax].text) : 0;
+		items[i].image = NULL;
+	}
+	if(!limg) imagewidth = imageheight = longestedge = imagegaps = 0;
+	inputw = maxstr ? textw(dc, maxstr) : 0;
 	lines = MIN(lines, i);
 }
 
-static void
-run(void)
-{
+void
+drawimage(void) {
+	static int width = 0, height = 0;
+	static char *limg = NULL;
+
+	if(sel && sel->image && strcmp(sel->image, limg?limg:"")) {
+		if(longestedge) loadimagecache(sel->image, &width, &height);
+	} else if((!sel || !sel->image) && image) {
+		imlib_free_image();
+		image = NULL;
+	}
+	if(image && longestedge) {
+		int leftmargin = imagegaps;
+		if(mh != bh+height+imagegaps*2) {
+			resizetoimageheight(height);
+		}
+		if(imagemode == MODE_TOP) {
+			imlib_render_image_on_drawable(leftmargin+(imagewidth-width)/2, bh+imagegaps);
+		} else if(imagemode == MODE_BOTTOM) {
+			imlib_render_image_on_drawable(leftmargin+(imagewidth-width)/2, mh-height-imagegaps);
+		} else if(imagemode == MODE_CENTER) {
+			imlib_render_image_on_drawable(leftmargin+(imagewidth-width)/2, (mh-bh-height)/2+bh);
+		} else {
+			int minh = MIN(imageheight, mh-bh-imagegaps*2);
+			if (height > width) minh = height;
+			imlib_render_image_on_drawable(leftmargin+(imagewidth-width)/2, (minh-height)/2+bh+imagegaps);
+		}
+	}
+
+	if(sel) limg = sel->image;
+	else limg = NULL;
+}
+
+void
+run(void) {
 	XEvent ev;
 
-	while (!XNextEvent(dpy, &ev)) {
-		if (XFilterEvent(&ev, win))
+	while(!XNextEvent(dc->dpy, &ev)) {
+		if(XFilterEvent(&ev, win))
 			continue;
 		switch(ev.type) {
-		case DestroyNotify:
-			if (ev.xdestroywindow.window != win)
-				break;
-			cleanup();
-			exit(1);
 		case Expose:
-			if (ev.xexpose.count == 0)
-				drw_map(drw, win, 0, 0, mw, mh);
-			break;
-		case FocusIn:
-			/* regrab focus from parent window */
-			if (ev.xfocus.window != win)
-				grabfocus();
+			if(ev.xexpose.count == 0) {
+				mapdc(dc, win, mw, mh);
+				drawimage();
+			}
 			break;
 		case KeyPress:
 			keypress(&ev.xkey);
+			drawimage();
 			break;
 		case SelectionNotify:
-			if (ev.xselection.property == utf8)
+			if(ev.xselection.property == utf8)
 				paste();
 			break;
 		case VisibilityNotify:
-			if (ev.xvisibility.state != VisibilityUnobscured)
-				XRaiseWindow(dpy, win);
+			if(ev.xvisibility.state != VisibilityUnobscured)
+				XRaiseWindow(dc->dpy, win);
 			break;
 		}
 	}
 }
 
-static void
-setup(void)
-{
-	int x, y, i, j;
-	unsigned int du;
+void
+jumptoindex(unsigned int index) {
+	unsigned int i;
+	sel = curr = matches;
+	calcoffsets();
+	for(i = 1; i < index; ++i) {
+		if(sel && sel->right && (sel = sel->right) == next) {
+			curr = next;
+			calcoffsets();
+		}
+	}
+}
+
+void
+resizetoimageheight(int imageheight) {
+	int omh = mh, olines = lines;
+	lines = reallines;
+	if(lines * bh < imageheight+imagegaps*2) lines = (imageheight+imagegaps*2)/bh;
+	mh = (lines + 1) * bh;
+	if(mh-bh < imageheight+imagegaps*2) mh = imageheight+imagegaps*2+bh;
+	if(!win || omh == mh) return;
+	XResizeWindow(dc->dpy, win, mw, mh);
+	resizedc(dc, mw, mh);
+
+	if(olines != lines) {
+		Item *item;
+		unsigned int i = 1;
+		for (item = matches; item && item != sel; item = item->right) ++i;
+		jumptoindex(i);
+	}
+	drawmenu();
+}
+
+void
+setup(void) {
+	int x, y, screen = DefaultScreen(dc->dpy);
+	Window root = RootWindow(dc->dpy, screen);
 	XSetWindowAttributes swa;
 	XIM xim;
-	Window w, dw, *dws;
-	XWindowAttributes wa;
-	XClassHint ch = {"dmenu", "dmenu"};
 #ifdef XINERAMA
+	int n;
 	XineramaScreenInfo *info;
-	Window pw;
-	int a, di, n, area = 0;
 #endif
-	/* init appearance */
-	for (j = 0; j < SchemeLast; j++)
-		scheme[j] = drw_scm_create(drw, colors[j], 2);
 
-	clip = XInternAtom(dpy, "CLIPBOARD",   False);
-	utf8 = XInternAtom(dpy, "UTF8_STRING", False);
+	normcol = initcolor(dc, normfgcolor, normbgcolor);
+	selcol = initcolor(dc, selfgcolor, selbgcolor);
+	outcol = initcolor(dc, outfgcolor, outbgcolor);
+
+	clip = XInternAtom(dc->dpy, "CLIPBOARD",   False);
+	utf8 = XInternAtom(dc->dpy, "UTF8_STRING", False);
 
 	/* calculate menu geometry */
-	bh = drw->fonts->h + 2;
+	bh = dc->font.height + 2;
 	lines = MAX(lines, 0);
-	mh = (lines + 1) * bh;
+	reallines = lines;
+	resizetoimageheight(imageheight);
+
 #ifdef XINERAMA
-	i = 0;
-	if (parentwin == root && (info = XineramaQueryScreens(dpy, &n))) {
-		XGetInputFocus(dpy, &w, &di);
-		if (mon >= 0 && mon < n)
+	if((info = XineramaQueryScreens(dc->dpy, &n))) {
+		int a, j, di, i = 0, area = 0;
+		unsigned int du;
+		Window w, pw, dw, *dws;
+		XWindowAttributes wa;
+
+		XGetInputFocus(dc->dpy, &w, &di);
+		if(mon != -1 && mon < n)
 			i = mon;
-		else if (w != root && w != PointerRoot && w != None) {
+		if(!i && w != root && w != PointerRoot && w != None) {
 			/* find top-level window containing current input focus */
 			do {
-				if (XQueryTree(dpy, (pw = w), &dw, &w, &dws, &du) && dws)
+				if(XQueryTree(dc->dpy, (pw = w), &dw, &w, &dws, &du) && dws)
 					XFree(dws);
-			} while (w != root && w != pw);
+			} while(w != root && w != pw);
 			/* find xinerama screen with which the window intersects most */
-			if (XGetWindowAttributes(dpy, pw, &wa))
-				for (j = 0; j < n; j++)
-					if ((a = INTERSECT(wa.x, wa.y, wa.width, wa.height, info[j])) > area) {
+			if(XGetWindowAttributes(dc->dpy, pw, &wa))
+				for(j = 0; j < n; j++)
+					if((a = INTERSECT(wa.x, wa.y, wa.width, wa.height, info[j])) > area) {
 						area = a;
 						i = j;
 					}
 		}
 		/* no focused window is on screen, so use pointer location instead */
-		if (mon < 0 && !area && XQueryPointer(dpy, root, &dw, &dw, &x, &y, &di, &di, &du))
-			for (i = 0; i < n; i++)
-				if (INTERSECT(x, y, 1, 1, info[i]))
+		if(mon == -1 && !area && XQueryPointer(dc->dpy, root, &dw, &dw, &x, &y, &di, &di, &du))
+			for(i = 0; i < n; i++)
+				if(INTERSECT(x, y, 1, 1, info[i]))
 					break;
 
 		x = info[i].x_org;
 		y = info[i].y_org + (topbar ? 0 : info[i].height - mh);
 		mw = info[i].width;
 		XFree(info);
-	} else
+	}
+	else
 #endif
 	{
-		if (!XGetWindowAttributes(dpy, parentwin, &wa))
-			die("could not get embedding window attributes: 0x%lx",
-			    parentwin);
 		x = 0;
-		y = topbar ? 0 : wa.height - mh;
-		mw = wa.width;
+		y = topbar ? 0 : DisplayHeight(dc->dpy, screen) - mh;
+		mw = DisplayWidth(dc->dpy, screen);
 	}
-	promptw = (prompt && *prompt) ? TEXTW(prompt) - lrpad / 4 : 0;
+	promptw = (prompt && *prompt) ? textw(dc, prompt) : 0;
 	inputw = MIN(inputw, mw/3);
-	match();
 
 	/* create menu window */
 	swa.override_redirect = True;
-	swa.background_pixel = scheme[SchemeNorm][ColBg].pixel;
+	swa.background_pixel = normcol->BG;
 	swa.event_mask = ExposureMask | KeyPressMask | VisibilityChangeMask;
-	win = XCreateWindow(dpy, parentwin, x, y, mw, mh, 0,
-	                    CopyFromParent, CopyFromParent, CopyFromParent,
+	win = XCreateWindow(dc->dpy, root, x, y, mw, mh, 0,
+	                    DefaultDepth(dc->dpy, screen), CopyFromParent,
+	                    DefaultVisual(dc->dpy, screen),
 	                    CWOverrideRedirect | CWBackPixel | CWEventMask, &swa);
-	XSetClassHint(dpy, win, &ch);
-
-
-	/* input methods */
-	if ((xim = XOpenIM(dpy, NULL, NULL, NULL)) == NULL)
-		die("XOpenIM failed: could not open input device");
 
+	/* open input methods */
+	xim = XOpenIM(dc->dpy, NULL, NULL, NULL);
 	xic = XCreateIC(xim, XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
 	                XNClientWindow, win, XNFocusWindow, win, NULL);
 
-	XMapRaised(dpy, win);
-	if (embed) {
-		XSelectInput(dpy, parentwin, FocusChangeMask | SubstructureNotifyMask);
-		if (XQueryTree(dpy, parentwin, &dw, &w, &dws, &du) && dws) {
-			for (i = 0; i < du && dws[i] != win; ++i)
-				XSelectInput(dpy, dws[i], FocusChangeMask);
-			XFree(dws);
-		}
-		grabfocus();
-	}
-	drw_resize(drw, mw, mh);
-	drawmenu();
-}
-
-static void
-usage(void)
-{
-	fputs("usage: dmenu [-bfiv] [-l lines] [-p prompt] [-fn font] [-m monitor]\n"
-	      "             [-nb color] [-nf color] [-sb color] [-sf color] [-w windowid]\n", stderr);
-	exit(1);
-}
-
-int
-main(int argc, char *argv[])
-{
-	XWindowAttributes wa;
-	int i, fast = 0;
-
-	for (i = 1; i < argc; i++)
-		/* these options take no arguments */
-		if (!strcmp(argv[i], "-v")) {      /* prints version information */
-			puts("dmenu-"VERSION);
-			exit(0);
-		} else if (!strcmp(argv[i], "-b")) /* appears at the bottom of the screen */
-			topbar = 0;
-		else if (!strcmp(argv[i], "-f"))   /* grabs keyboard before reading stdin */
-			fast = 1;
-		else if (!strcmp(argv[i], "-i")) { /* case-insensitive item matching */
-			fstrncmp = strncasecmp;
-			fstrstr = cistrstr;
-		} else if (i + 1 == argc)
-			usage();
-		/* these options take one argument */
-		else if (!strcmp(argv[i], "-l"))   /* number of lines in vertical list */
-			lines = atoi(argv[++i]);
-		else if (!strcmp(argv[i], "-m"))
-			mon = atoi(argv[++i]);
-		else if (!strcmp(argv[i], "-p"))   /* adds prompt to left of input field */
-			prompt = argv[++i];
-		else if (!strcmp(argv[i], "-fn"))  /* font or font set */
-			fonts[0] = argv[++i];
-		else if (!strcmp(argv[i], "-nb"))  /* normal background color */
-			colors[SchemeNorm][ColBg] = argv[++i];
-		else if (!strcmp(argv[i], "-nf"))  /* normal foreground color */
-			colors[SchemeNorm][ColFg] = argv[++i];
-		else if (!strcmp(argv[i], "-sb"))  /* selected background color */
-			colors[SchemeSel][ColBg] = argv[++i];
-		else if (!strcmp(argv[i], "-sf"))  /* selected foreground color */
-			colors[SchemeSel][ColFg] = argv[++i];
-		else if (!strcmp(argv[i], "-w"))   /* embedding window id */
-			embed = argv[++i];
-		else
-			usage();
+	XMapRaised(dc->dpy, win);
+	resizedc(dc, mw, mh);
 
-	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
-		fputs("warning: no locale support\n", stderr);
-	if (!(dpy = XOpenDisplay(NULL)))
-		die("cannot open display");
-	screen = DefaultScreen(dpy);
-	root = RootWindow(dpy, screen);
-	if (!embed || !(parentwin = strtol(embed, NULL, 0)))
-		parentwin = root;
-	if (!XGetWindowAttributes(dpy, parentwin, &wa))
-		die("could not get embedding window attributes: 0x%lx",
-		    parentwin);
-	drw = drw_create(dpy, screen, root, wa.width, wa.height);
-	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
-		die("no fonts could be loaded.");
-	lrpad = drw->fonts->h;
-
-#ifdef __OpenBSD__
-	if (pledge("stdio rpath", NULL) == -1)
-		die("pledge");
-#endif
+	imlib_set_cache_size(8192 * 1024);
+	imlib_context_set_blend(1);
+	imlib_context_set_dither(1);
+	imlib_set_color_usage(128);
+	imlib_context_set_display(dc->dpy);
+	imlib_context_set_visual(DefaultVisual(dc->dpy, screen));
+	imlib_context_set_colormap(DefaultColormap(dc->dpy, screen));
+	imlib_context_set_drawable(win);
 
-	if (fast && !isatty(0)) {
-		grabkeyboard();
-		readstdin();
-	} else {
-		readstdin();
-		grabkeyboard();
-	}
-	setup();
-	run();
+    match();
+	jumptoindex(selected);
+	drawmenu();
+}
 
-	return 1; /* unreachable */
+void
+usage(void) {
+	fputs("usage: dmenu [-b] [-f] [-i] [-g] [-l lines] [-p prompt] [-fn font] [-m monitor]\n"
+	      "             [-nb color] [-nf color] [-sb color] [-sf color] [-si index] [-is size] [-ia align] [-v]\n", stderr);
+	exit(EXIT_FAILURE);
 }
--- dmenu_path	2020-06-05 15:58:48.637068984 +0000
+++ dmenu_path-patched	2020-06-05 20:22:55.703970771 +0000
@@ -1,10 +1,10 @@
 #!/bin/sh
-
-cachedir="${XDG_CACHE_HOME:-"$HOME/.cache"}"
-cache="$cachedir/dmenu_run"
-
-[ ! -e "$cachedir" ] && mkdir -p "$cachedir"
-
+cachedir=${XDG_CACHE_HOME:-"$HOME/.cache"}
+if [ -d "$cachedir" ]; then
+	cache=$cachedir/dmenu_run
+else
+	cache=$HOME/.dmenu_cache # if no xdg dir, fall back to dotfile in ~
+fi
 IFS=:
 if stest -dqr -n "$cache" $PATH; then
 	stest -flx $PATH | sort -u | tee "$cache"
--- LICENSE	2020-06-05 15:58:48.637068984 +0000
+++ LICENSE-patched	2020-06-05 20:22:55.703970771 +0000
@@ -1,15 +1,13 @@
 MIT/X Consortium License
 
-© 2006-2019 Anselm R Garbe <anselm@garbe.ca>
-© 2006-2008 Sander van Dijk <a.h.vandijk@gmail.com>
-© 2006-2007 Michał Janeczek <janeczek@gmail.com>
-© 2007 Kris Maglione <jg@suckless.org>
+@ 2013 Jari Vetoniemi <mailroxas@gmail.com>
+© 2006-2013 Anselm R Garbe <anselm@garbe.us>
+© 2010-2012 Connor Lane Smith <cls@lubutu.com>
 © 2009 Gottox <gottox@s01.de>
 © 2009 Markus Schnalke <meillo@marmaro.de>
 © 2009 Evan Gates <evan.gates@gmail.com>
-© 2010-2012 Connor Lane Smith <cls@lubutu.com>
-© 2014-2019 Hiltjo Posthuma <hiltjo@codemadness.org>
-© 2015-2019 Quentin Rameau <quinq@fifth.space>
+© 2006-2008 Sander van Dijk <a dot h dot vandijk at gmail dot com>
+© 2006-2007 Michał Janeczek <janeczek at gmail dot com>
 
 Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files (the "Software"),
--- Makefile	2020-06-05 15:58:48.637068984 +0000
+++ Makefile-patched	2020-06-05 20:22:55.703970771 +0000
@@ -3,62 +3,70 @@
 
 include config.mk
 
-SRC = drw.c dmenu.c stest.c util.c
-OBJ = $(SRC:.c=.o)
+SRC = dmenu.c draw.c stest.c
+OBJ = ${SRC:.c=.o}
 
 all: options dmenu stest
 
 options:
 	@echo dmenu build options:
-	@echo "CFLAGS   = $(CFLAGS)"
-	@echo "LDFLAGS  = $(LDFLAGS)"
-	@echo "CC       = $(CC)"
+	@echo "CFLAGS   = ${CFLAGS}"
+	@echo "LDFLAGS  = ${LDFLAGS}"
+	@echo "CC       = ${CC}"
 
 .c.o:
-	$(CC) -c $(CFLAGS) $<
+	@echo CC -c $<
+	@${CC} -c $< ${CFLAGS}
 
 config.h:
-	cp config.def.h $@
+	@echo creating $@ from config.def.h
+	@cp config.def.h $@
 
-$(OBJ): arg.h config.h config.mk drw.h
+${OBJ}: config.h config.mk draw.h
 
-dmenu: dmenu.o drw.o util.o
-	$(CC) -o $@ dmenu.o drw.o util.o $(LDFLAGS)
+dmenu: dmenu.o draw.o
+	@echo CC -o $@
+	@${CC} -o $@ dmenu.o draw.o ${LDFLAGS}
 
 stest: stest.o
-	$(CC) -o $@ stest.o $(LDFLAGS)
+	@echo CC -o $@
+	@${CC} -o $@ stest.o ${LDFLAGS}
 
 clean:
-	rm -f dmenu stest $(OBJ) dmenu-$(VERSION).tar.gz
+	@echo cleaning
+	@rm -f dmenu stest ${OBJ} dmenu-${VERSION}.tar.gz
 
 dist: clean
-	mkdir -p dmenu-$(VERSION)
-	cp LICENSE Makefile README arg.h config.def.h config.mk dmenu.1\
-		drw.h util.h dmenu_path dmenu_run stest.1 $(SRC)\
-		dmenu-$(VERSION)
-	tar -cf dmenu-$(VERSION).tar dmenu-$(VERSION)
-	gzip dmenu-$(VERSION).tar
-	rm -rf dmenu-$(VERSION)
+	@echo creating dist tarball
+	@mkdir -p dmenu-${VERSION}
+	@cp LICENSE Makefile README config.mk dmenu.1 draw.h dmenu_path dmenu_run stest.1 ${SRC} dmenu-${VERSION}
+	@tar -cf dmenu-${VERSION}.tar dmenu-${VERSION}
+	@gzip dmenu-${VERSION}.tar
+	@rm -rf dmenu-${VERSION}
 
 install: all
-	mkdir -p $(DESTDIR)$(PREFIX)/bin
-	cp -f dmenu dmenu_path dmenu_run stest $(DESTDIR)$(PREFIX)/bin
-	chmod 755 $(DESTDIR)$(PREFIX)/bin/dmenu
-	chmod 755 $(DESTDIR)$(PREFIX)/bin/dmenu_path
-	chmod 755 $(DESTDIR)$(PREFIX)/bin/dmenu_run
-	chmod 755 $(DESTDIR)$(PREFIX)/bin/stest
-	mkdir -p $(DESTDIR)$(MANPREFIX)/man1
-	sed "s/VERSION/$(VERSION)/g" < dmenu.1 > $(DESTDIR)$(MANPREFIX)/man1/dmenu.1
-	sed "s/VERSION/$(VERSION)/g" < stest.1 > $(DESTDIR)$(MANPREFIX)/man1/stest.1
-	chmod 644 $(DESTDIR)$(MANPREFIX)/man1/dmenu.1
-	chmod 644 $(DESTDIR)$(MANPREFIX)/man1/stest.1
+	@echo installing executables to ${DESTDIR}${PREFIX}/bin
+	@mkdir -p ${DESTDIR}${PREFIX}/bin
+	@cp -f dmenu dmenu_path dmenu_run stest ${DESTDIR}${PREFIX}/bin
+	@chmod 755 ${DESTDIR}${PREFIX}/bin/dmenu
+	@chmod 755 ${DESTDIR}${PREFIX}/bin/dmenu_path
+	@chmod 755 ${DESTDIR}${PREFIX}/bin/dmenu_run
+	@chmod 755 ${DESTDIR}${PREFIX}/bin/stest
+	@echo installing manual pages to ${DESTDIR}${MANPREFIX}/man1
+	@mkdir -p ${DESTDIR}${MANPREFIX}/man1
+	@sed "s/VERSION/${VERSION}/g" < dmenu.1 > ${DESTDIR}${MANPREFIX}/man1/dmenu.1
+	@sed "s/VERSION/${VERSION}/g" < stest.1 > ${DESTDIR}${MANPREFIX}/man1/stest.1
+	@chmod 644 ${DESTDIR}${MANPREFIX}/man1/dmenu.1
+	@chmod 644 ${DESTDIR}${MANPREFIX}/man1/stest.1
 
 uninstall:
-	rm -f $(DESTDIR)$(PREFIX)/bin/dmenu\
-		$(DESTDIR)$(PREFIX)/bin/dmenu_path\
-		$(DESTDIR)$(PREFIX)/bin/dmenu_run\
-		$(DESTDIR)$(PREFIX)/bin/stest\
-		$(DESTDIR)$(MANPREFIX)/man1/dmenu.1\
-		$(DESTDIR)$(MANPREFIX)/man1/stest.1
+	@echo removing executables from ${DESTDIR}${PREFIX}/bin
+	@rm -f ${DESTDIR}${PREFIX}/bin/dmenu
+	@rm -f ${DESTDIR}${PREFIX}/bin/dmenu_path
+	@rm -f ${DESTDIR}${PREFIX}/bin/dmenu_run
+	@rm -f ${DESTDIR}${PREFIX}/bin/stest
+	@echo removing manual page from ${DESTDIR}${MANPREFIX}/man1
+	@rm -f ${DESTDIR}${MANPREFIX}/man1/dmenu.1
+	@rm -f ${DESTDIR}${MANPREFIX}/man1/stest.1
 
 .PHONY: all options clean dist install uninstall
--- README	2020-06-05 15:58:48.637068984 +0000
+++ README-patched	2020-06-05 20:22:55.703970771 +0000
@@ -1,11 +1,11 @@
-dmenu - dynamic menu
+dmenu-pango-imlib - dynamic menu (with pango && imlib)
 ====================
-dmenu is an efficient dynamic menu for X.
+Pango and imlib patched dmenu.
 
 
 Requirements
 ------------
-In order to build dmenu you need the Xlib header files.
+In order to build dmenu-pango-imlib you need the Xlib, pango and imlib header/library files
 
 
 Installation
@@ -22,3 +22,20 @@
 Running dmenu
 -------------
 See the man page for details.
+
+Thumbnails get cached according to XDG thumbnail spec.
+http://specifications.freedesktop.org/thumbnail-spec/thumbnail-spec-latest.html
+
+Pass -g to generate thumbnails immediatly for the piped images.
+Pass -is to specify image size (keeping aspect ratio).
+Pass -ia to specify image alignment (top-center/center/top/bottom/*-gapless, where top-center is default)
+Note, that using too big images cause slowdown because images are loaded each time, selection image differs from last image.
+
+Example pipe listing with images:
+IMG:/mnt/pictures/lolcat.jpg\tThis is a lolcat\n
+IMG:/mnt/pictures/david.jpg\tThis is a picture of david\n
+This is a item without a picture\n
+
+Additional options:
+Pass -si to specify starting index to dmenu.
+ex. -si 5 to start from item 5.
--- stest.c	2020-06-05 15:58:48.637068984 +0000
+++ stest.c-patched	2020-06-05 20:22:55.703970771 +0000
@@ -1,31 +1,66 @@
 /* See LICENSE file for copyright and license details. */
-#include <sys/stat.h>
-
 #include <dirent.h>
-#include <limits.h>
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-
-#include "arg.h"
-char *argv0;
+#include <sys/stat.h>
 
 #define FLAG(x)  (flag[(x)-'a'])
 
 static void test(const char *, const char *);
-static void usage(void);
 
-static int match = 0;
-static int flag[26];
+static bool match = false;
+static bool flag[26];
 static struct stat old, new;
 
-static void
-test(const char *path, const char *name)
-{
+int
+main(int argc, char *argv[]) {
+	struct dirent *d;
+	char buf[BUFSIZ], *p;
+	DIR *dir;
+	int opt;
+
+	while((opt = getopt(argc, argv, "abcdefghln:o:pqrsuvwx")) != -1)
+		switch(opt) {
+		case 'n': /* newer than file */
+		case 'o': /* older than file */
+			if(!(FLAG(opt) = !stat(optarg, (opt == 'n' ? &new : &old))))
+				perror(optarg);
+			break;
+		default:  /* miscellaneous operators */
+			FLAG(opt) = true;
+			break;
+		case '?': /* error: unknown flag */
+			fprintf(stderr, "usage: %s [-abcdefghlpqrsuvwx] [-n file] [-o file] [file...]\n", argv[0]);
+			exit(2);
+		}
+	if(optind == argc)
+		while(fgets(buf, sizeof buf, stdin)) {
+			if((p = strchr(buf, '\n')))
+				*p = '\0';
+			test(buf, buf);
+		}
+	for(; optind < argc; optind++)
+		if(FLAG('l') && (dir = opendir(argv[optind]))) {
+			/* test directory contents */
+			while((d = readdir(dir)))
+				if(snprintf(buf, sizeof buf, "%s/%s", argv[optind], d->d_name) < sizeof buf)
+					test(buf, d->d_name);
+			closedir(dir);
+		}
+		else
+			test(argv[optind], argv[optind]);
+
+	return match ? 0 : 1;
+}
+
+void
+test(const char *path, const char *name) {
 	struct stat st, ln;
 
-	if ((!stat(path, &st) && (FLAG('a') || name[0] != '.')        /* hidden files      */
+	if((!stat(path, &st) && (FLAG('a') || name[0] != '.')         /* hidden files      */
 	&& (!FLAG('b') || S_ISBLK(st.st_mode))                        /* block special     */
 	&& (!FLAG('c') || S_ISCHR(st.st_mode))                        /* character special */
 	&& (!FLAG('d') || S_ISDIR(st.st_mode))                        /* directory         */
@@ -41,69 +76,9 @@
 	&& (!FLAG('u') || st.st_mode & S_ISUID)                       /* set-user-id flag  */
 	&& (!FLAG('w') || access(path, W_OK) == 0)                    /* writable          */
 	&& (!FLAG('x') || access(path, X_OK) == 0)) != FLAG('v')) {   /* executable        */
-		if (FLAG('q'))
+		if(FLAG('q'))
 			exit(0);
-		match = 1;
+		match = true;
 		puts(name);
 	}
 }
-
-static void
-usage(void)
-{
-	fprintf(stderr, "usage: %s [-abcdefghlpqrsuvwx] "
-	        "[-n file] [-o file] [file...]\n", argv0);
-	exit(2); /* like test(1) return > 1 on error */
-}
-
-int
-main(int argc, char *argv[])
-{
-	struct dirent *d;
-	char path[PATH_MAX], *line = NULL, *file;
-	size_t linesiz = 0;
-	ssize_t n;
-	DIR *dir;
-	int r;
-
-	ARGBEGIN {
-	case 'n': /* newer than file */
-	case 'o': /* older than file */
-		file = EARGF(usage());
-		if (!(FLAG(ARGC()) = !stat(file, (ARGC() == 'n' ? &new : &old))))
-			perror(file);
-		break;
-	default:
-		/* miscellaneous operators */
-		if (strchr("abcdefghlpqrsuvwx", ARGC()))
-			FLAG(ARGC()) = 1;
-		else
-			usage(); /* unknown flag */
-	} ARGEND;
-
-	if (!argc) {
-		/* read list from stdin */
-		while ((n = getline(&line, &linesiz, stdin)) > 0) {
-			if (n && line[n - 1] == '\n')
-				line[n - 1] = '\0';
-			test(line, line);
-		}
-		free(line);
-	} else {
-		for (; argc; argc--, argv++) {
-			if (FLAG('l') && (dir = opendir(*argv))) {
-				/* test directory contents */
-				while ((d = readdir(dir))) {
-					r = snprintf(path, sizeof path, "%s/%s",
-					             *argv, d->d_name);
-					if (r >= 0 && (size_t)r < sizeof path)
-						test(path, d->d_name);
-				}
-				closedir(dir);
-			} else {
-				test(*argv, *argv);
-			}
-		}
-	}
-	return match ? 0 : 1;
-}
